name: Electromart CI/CD

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ECR_REPO_BACKEND: electromart/backend
  ECR_REPO_FRONTEND: electromart/frontend

jobs:
  # ------------------------------------------------------------------
  # JOB 1: BUILD & PUSH (Fetches Web IP Dynamically)
  # ------------------------------------------------------------------
  build-and-push:
    name: ðŸ—ï¸ Build & Push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. Configure AWS (So we can query IPs and Push images)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 2. Dynamic IP Lookup (The Fix!)
      - name: ðŸ” Find Web Server IP (LB_IP)
        id: get-ip
        run: |
          echo "Querying AWS for Web Server Public IP..."
          # Find the instance tagged 'electromart-web' and get its Public IP
          LB_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=electromart-web" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].PublicIpAddress" \
            --output text)

          if [[ -z "$LB_IP" || "$LB_IP" == "None" ]]; then
            echo "âŒ Error: Could not find Web Server. Is it running?"
            exit 1
          fi

          echo "âœ… Found Web IP: $LB_IP"
          echo "LB_IP=$LB_IP" >> $GITHUB_ENV

      # 3. Build & Push Backend
      - name: Build Backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPO_BACKEND:$IMAGE_TAG ./app/backend
          docker push $ECR_REGISTRY/$ECR_REPO_BACKEND:$IMAGE_TAG

      # 4. Build & Push Frontend (Uses Dynamic LB_IP)
      - name: Build Frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: latest
        run: |
          echo "Building Frontend with API URL: http://${{ env.LB_IP }}:5000"
          docker build -t $ECR_REGISTRY/$ECR_REPO_FRONTEND:$IMAGE_TAG \
            --build-arg REACT_APP_API_URL=http://${{ env.LB_IP }}:5000 \
            ./app/frontend
          docker push $ECR_REGISTRY/$ECR_REPO_FRONTEND:$IMAGE_TAG

  # ------------------------------------------------------------------
  # JOB 2: DEPLOY (Fetches Bastion IP Dynamically)
  # ------------------------------------------------------------------
  deploy:
    name: ðŸš€ Deploy
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 1. Dynamic Bastion Lookup (The Fix!)
      - name: ðŸ” Find Bastion IP
        id: get-bastion
        run: |
          echo "Querying AWS for Bastion Public IP..."
          BASTION_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=electromart-bastion" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].PublicIpAddress" \
            --output text)

          if [[ -z "$BASTION_IP" || "$BASTION_IP" == "None" ]]; then
            echo "âŒ Error: Could not find Bastion Server."
            exit 1
          fi

          echo "âœ… Found Bastion IP: $BASTION_IP"
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_ENV

      # 2. Install Ansible
      - name: Install Ansible
        run: pip install ansible boto3 botocore

      # 3. Setup SSH Key
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # 4. Generate Inventory (Using AWS CLI for Private IPs)
      - name: Generate Inventory
        run: |
          # Fetch Private IPs for internal connection
          WEB_PRIVATE=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=electromart-web" --query "Reservations[].Instances[].PrivateIpAddress" --output text)
          APP_PRIVATE=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=electromart-app" --query "Reservations[].Instances[].PrivateIpAddress" --output text)
          DB_PRIVATE=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=electromart-db" --query "Reservations[].Instances[].PrivateIpAddress" --output text)

          cd ansible
          cat > inventory.ini <<EOF
          [bastion]
          bastion1 ansible_host=${{ env.BASTION_IP }}

          [web]
          web1 ansible_host=$WEB_PRIVATE

          [app]
          app1 ansible_host=$APP_PRIVATE

          [db]
          db1 ansible_host=$DB_PRIVATE

          [all:vars]
          ansible_user=ubuntu
          ansible_ssh_private_key_file=~/.ssh/id_rsa
          ansible_ssh_common_args='-o StrictHostKeyChecking=no -o IdentitiesOnly=yes'

          [jumped_hosts:children]
          web
          app
          db

          [jumped_hosts:vars]
          ansible_ssh_common_args='-o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o ProxyCommand="ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -i ~/.ssh/id_rsa -W %h:%p -q ubuntu@${{ env.BASTION_IP }}"'
          EOF

      # 5. Run Deployment
      - name: Run Playbook
        run: |
          cd ansible
          ansible-playbook -i inventory.ini deploy-containers.yml
